<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>
    <body>
        <script>
            let canvas, ctx, population, walls, gameSpeed = 1, a

            function createCanvas(width, height) {
                canvas = document.createElement('canvas')
                ctx = canvas.getContext('2d')
                canvas.width = width
                canvas.height = height
                document.body.append(canvas)
            }

            function createPopulation(size) {
                population = []

                for (let i = 0; i < size; i++) {
                    population.push(new Square())
                }
            }

            class Wall {
                constructor() {
                    if (walls) this.x = canvas.width + 150 * walls.length
                    else this.x = canvas.width
                    this.height = Math.floor(Math.random() * 25)
                    this.width =  3
                    this.y = canvas.height - this.height
                    this.color = 'white'
                    this.isOutOfView = false
                }
                move() {
                    if (this.x < 0 - this.width * 2) this.isOutOfView = true
                    else this.x -= gameSpeed
                }
            }

            function sortByFitness(a, b) {
                return a.fitness - b.fitness
            }

            function run() {
                ctx.fillStyle = 'black'
                ctx.fillRect(0, 0, canvas.width, canvas.height)

                let i = 0
                for (let square of population) {
                    for (let wall of walls) {
                        if (square.isAlive) {
                            if (isThereCollision(square, wall)) {
                                square.isAlive = false
                            }
                        }
                    }
                    square.fall()
                    calcFitness(square, i)
                    if (square.isAlive) square.feedForward()
                    draw(square)
                    i++
                }

                for (let i = 0; i < walls.length; i++) {
                    walls[i].move()
                    draw(walls[i])

                    if (walls[i].isOutOfView) {
                        walls[i] = new Wall()
                    }
                }

                const areTheyAllDead = population
                    .every(square => square.isAlive == false)

                if (areTheyAllDead) {
                    gameSpeed = 1
                    cloneTheFittest()

                    for (let i = 0; i < population.length; i++) {
                        if (i != population.length - 1) {
                            population[i].cromossome.mutate()
                        }
                        population[i] = new Square(population[i].cromossome.dna)
                    }
                    createWalls(5)
                } else {
                    gameSpeed += 0.001
                }
                requestAnimationFrame(run)
            }

            function cloneTheFittest() {
                population.sort(sortByFitness)
                
                for (let i = 0; i < population.length; i++) {
                    if (i != population.length - 1) {
                        population[i].cromossome.dna = population[population.length - 1].cromossome.dna
                    }
                }
                console.log(population)
            }

            class Perceptron {
                feedForward() {
                    const { 
                        wallHeight, 
                        wallDistance, 
                        wallWidth 
                    } = getTheClosestWall(this)

                    const input = [
                        wallDistance, 
                        wallHeight, 
                        gameSpeed, 
                        this.height, 
                        this.width, 
                        wallWidth
                    ]

                    const { 
                        inpSize,
                        hiddenSize, 
                        hiddenAmount, 
                        outpSize, 
                        weightAmount 
                    } = calcWeightAmount(6, 1, 1, 2)

                    const hidden = []
                    const nodeAmount = inpSize + hiddenSize * hiddenAmount
                    const output = []
                    for (let i = 0; i < hiddenAmount; i++) {
                        hidden.push(new Array(hiddenSize))

                        for (let k = 0; k < hidden[i].length; k++) {
                            hidden[i][k] = 0
                        }
                    }
                    
                    output.push(new Array(outpSize))
                    
                    for (let i = 0; i < outpSize; i++) {
                        output[0][i] = 0
                    }

                    // calcs the first hidden layer
                    for (let i = 0; i < hiddenSize; i++) {
                        for (let k = 0; k < input.length; k++) {
                            hidden[0][i] += input[k] * this.cromossome.dna[k][i]
                        }
                    }

                    // for (let i = 0; i < hiddenAmount * hiddenSize; i++) {
                    //     if (hiddenAmount == 1) break
                    //     for (let k = 1; k < hiddenSize; k++) {
                    //         console.log(hidden[0][k])
                    //         // hidden[1][i] += hidden[0][k] * this.cromossome.dna[k][i]
                    //         // this.cromossome.dna[k][i] = 0
                    //     }
                    // }

                    for (let i = 0; i < outpSize; i++) {
                        for (let k = 0; k < hidden[0].length; k++) {
                            output[0][i] += hidden[0][k] * this.cromossome.dna[k + hiddenSize * hiddenAmount + 2][i]
                        }
                    }
                    if (this.#stepBack(output[0][0]) == 1) this.jump()
                    if (this.#stepBack(output[0][1] == 1)) this.crouch()
                    
                    // if (this.#sigmoid(output[0][0]) > 0.55) this.crouch()
                    // else if (this.#sigmoid(output[0][0])  < 0.40) this.jump()
                }
                #sigmoid(x) {
                    return 1 / (1 + Math.pow(Math.E, -x))
                }
                #stepBack(x) {
                    if (x >= 1) return 1
                    return 0
                }
            }

            class Square extends Perceptron {
                constructor(dna) {
                    super()
                    this.cromossome = new Cromossome()
                    if (dna) this.cromossome.dna = dna
                    this.fitness = 0
                    this._width = 10
                    this.hasJustScored = false
                    this.width = this._width
                    this._height = 19
                    this.height = this._height
                    this.color = newColor()
                    this.isOnTheAir = false
                    this.velocity = 0
                    this.isAlive = true
                    this.x = 10
                    this.y = canvas.height - this.height
                    this.isCrouching = false
                }
                fall() {
                    if (!this.isAlive) this.x--
                    
                    else if (this.y > canvas.height - this.height) {
                        this.isOnTheAir = false
                        this.y = canvas.height - this.height
                    } else if (this.isAlive && this.isOnTheAir) {
                        this.velocity += 1
                        this.y += this.velocity
                    }
                }
                jump() {
                    if (!this.isOnTheAir) {
                        this.velocity = -10.2
                        this.y += this.velocity
                        this.height = this._height
                        this.width = this._width
                        this.isOnTheAir = true
                        this.isCrouching = false
                    }
                }
                crouch() {
                    if (!this.isCrouching) {
                        this.height = this.height / 2
                        this.width += this.width / 2
                        this.y += this.height
                        this.velocity += 10
                        this.isCrouching = true
                    }
                }
            }

            function calcFitness(square, i) {
                if (isThereCollision(square, getTheClosestWall(square).wall, 'onlyX') && !square.hasJustScored && population[i].isAlive) {
                    population[i].fitness++
                    population[i].hasJustScored = true
                    setTimeout(() => {
                        population[i].hasJustScored = false
                    }, 150)
                }
            }

            function isThereCollision(a, b, option) {
                const disX = a.x - b.x
                const disY = a.y - b.y

                if (option == 'onlyX' && !(disY > -a.height && disY < b.height)) 
                    return disX > -a.width && disX < b.width

                if (disX > -a.width && disX < b.width &&
                    disY > -a.height && disY < b.height) return true
                return false
            }

            function draw(that) {
                ctx.fillStyle = that.color
                ctx.fillRect(that.x, that.y, that.width, that.height)
            }

            addEventListener('keydown', ({ key }) => {
                if (key == ' ') population[0].jump()
            })

            function calcWeightAmount(inpSize, hiddenSize, hiddenAmount, outpSize) {
                let weightAmount = inpSize * hiddenSize

                for (let c = 0; c < hiddenAmount; c++) {
                    if (c == hiddenAmount - 1) {
                        weightAmount += hiddenSize * outpSize
                    } else {
                        weightAmount += hiddenSize * hiddenSize
                    }
                }
                return {
                    inpSize: inpSize,
                    hiddenSize: hiddenSize,
                    hiddenAmount: hiddenAmount,
                    outpSize: outpSize,
                    weightAmount: weightAmount
                }
            }

            function getTheClosestWall(square) {
                let bestIndex = 0
                let bestX = Infinity

                for (let i = 0; i < walls.length; i++) {
                    if (walls[i].x > square.x && walls[i].x < bestX) {
                        bestIndex = i
                        bestX = walls[i].x
                    } 
                }
                return {
                    wallHeight: walls[bestIndex].height,
                    wallDistance: Math.abs(walls[bestIndex].x - square.x),
                    wallWidth: walls[bestIndex].width,
                    wall: walls[bestIndex]
                }
            }

            function createWalls(amount) {
                walls = []

                for (let i = 0; i < amount; i++) {
                    walls.push(new Wall())
                }
            }

            function newColor() {
                const hexadecimal = '0123456789ABCDEF'
                let color = '#'

                for (let i = 0; i < 6; i++) {
                    color += hexadecimal[Math.floor(Math.random() * 16)]
                }
                return color
            }

            class Cromossome {
                constructor() {
                    this.dna = []

                    const { 
                        inpSize,
                        hiddenSize, 
                        hiddenAmount, 
                        outpSize, 
                        weightAmount 
                    } = calcWeightAmount(6, 1, 1, 2)

                    const nodeAmount = inpSize + hiddenSize * hiddenAmount

                    for (let i = 0; i < nodeAmount; i++) {
                        if (i < inpSize) this.dna.push(new Array(hiddenSize))
                        else if (i >= nodeAmount - hiddenSize) this.dna.push(new Array(outpSize))
                        else this.dna.push(new Array(hiddenSize))

                        for (let k = 0; k < this.dna[i].length; k++) {
                            this.dna[i][k] = this.#newWeight()
                        }
                    }
                }
                mutate() {
                    const randCol = Math.floor(Math.random() * this.dna.length)
                    const randRow = Math.floor(Math.random() * this.dna[randCol].length)
                    this.dna[randCol][randRow] = this.#newWeight()
                }
                #newWeight = function() {
                    if (Math.random() > 0.5) return Math.random()
                    return -Math.random()
                }
            }
            
            createCanvas(300, 300)
            createPopulation(152)
            createWalls(3)

            run()
        </script>
    </body>
</html>