<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>
    <body>
        <script>
            let canvas, ctx, population, walls, gameSpeed = 1, generation = 0

            function createCanvas(width, height) {
                canvas = document.createElement('canvas')
                ctx = canvas.getContext('2d')
                canvas.width = width
                canvas.height = height
                document.body.append(canvas)
            }

            function createPopulation(size) {
                population = []

                for (let i = 0; i < size; i++) {
                    population.push(new Square())
                }
            }

            function Wall() {
                if (walls) this.x = canvas.width + 150 * walls.length
                else this.x = canvas.width

                this.height = Math.floor(Math.random() * 25)
                this.width =  3
                this.y = canvas.height - this.height
                this.color = 'white'
                this.isOutOfView = false

                this.move = function() {
                    if (this.x < 0 - this.width * 2) this.isOutOfView = true
                    else this.x -= gameSpeed
                }
            }

            function run() {
                ctx.fillStyle = 'black'
                ctx.fillRect(0, 0, canvas.width, canvas.height)

                let i = 0
                for (let square of population) {
                    for (let wall of walls) {
                        if (square.isAlive) {
                            if (isThereCollision(square, wall)) {
                                square.isAlive = false
                            }
                        }
                    }
                    square.fall()
                    calcFitness(square, i)
                    if (square.isAlive) square.feedForward()
                    draw(square)
                    i++
                }

                for (let i = 0; i < walls.length; i++) {
                    walls[i].move()
                    draw(walls[i])

                    if (walls[i].isOutOfView) {
                        walls[i] = new Wall()
                    }
                }

                const areTheyAllDead = population
                    .every(square => square.isAlive == false)

                if (areTheyAllDead) {
                    gameSpeed = 1
                    population.sort((a, b) => a.fitness - b.fitness)

                    generation++
                    console.log('Generation:', generation)
                    console.log('Best fitness: ', population[population.length - 1].fitness)

                    const bestDna = population[population.length - 1].dna.slice()

                    for (let i = 0; i < population.length; i++) {
                        if (i != population.length - 1 && Math.random() > 0.1) {
                            population[i].dna = mutateBestDna(bestDna)
                        }
                        population[i] = new Square(population[i].dna)
                    }
                    createWalls(5)
                } else {
                    gameSpeed += 0.001
                }
                requestAnimationFrame(run)
            }

            function newDna() {
                const { 
                    inpSize,
                    hiddenSize, 
                    hiddenAmount, 
                    outpSize, 
                    weightAmount 
                } = calcWeightAmount(5, 3, 1, 1)

                const nodeAmount = inpSize + hiddenSize * hiddenAmount

                const arr = []
                for (let i = 0; i < nodeAmount; i++) {
                    if (i < inpSize) arr.push(new Array(hiddenSize))
                    else if (i >= nodeAmount - hiddenSize) arr.push(new Array(outpSize))
                    else arr.push(new Array(hiddenSize))

                    for (let k = 0; k < arr[i].length; k++) {
                        arr[i][k] = newWeight()
                    }
                }
                return arr
            }

            function Square(dna) {
                if (dna) this.dna = dna
                else this.dna = newDna()

                this.fitness = 0
                this._width = 10
                this.hasJustScored = false
                this.width = this._width
                this._height = 19

                
                this.feedForward = function() {
                    const { 
                        wallHeight, 
                        wallDistance, 
                        wallWidth 
                    } = getTheClosestWall(this)

                    const input = [
                        wallDistance, 
                        wallHeight, 
                        gameSpeed, 
                        this.height, 
                        this.width, 
                    ]

                    const { 
                        inpSize,
                        hiddenSize, 
                        hiddenAmount, 
                        outpSize, 
                        weightAmount 
                    } = calcWeightAmount(5, 3, 1, 1)

                    const hidden = []
                    const nodeAmount = inpSize + hiddenSize * hiddenAmount
                    const output = []
                    for (let i = 0; i < hiddenAmount; i++) {
                        hidden.push(new Array(hiddenSize))

                        for (let k = 0; k < hidden[i].length; k++) {
                            hidden[i][k] = 0
                        }
                    }
                    
                    output.push(new Array(outpSize))
                    
                    for (let i = 0; i < outpSize; i++) {
                        output[0][i] = 0
                    }

                    // calcs the first hidden layer
                    for (let i = 0; i < hiddenSize; i++) {
                        for (let k = 0; k < input.length; k++) {
                            hidden[0][i] += input[k] * this.dna[k][i]
                        }
                    }

                    // for (let i = 0; i < hiddenAmount * hiddenSize; i++) {
                    //     if (hiddenAmount == 1) break
                    //     for (let k = 1; k < hiddenSize; k++) {
                    //         console.log(hidden[0][k])
                    //         // hidden[1][i] += hidden[0][k] * this.cromossome.dna[k][i]
                    //         // this.cromossome.dna[k][i] = 0
                    //     }
                    // }

                    for (let i = 0; i < outpSize; i++) {
                        for (let k = 0; k < hidden[0].length; k++) {
                            output[0][i] += hidden[0][k] * this.dna[k + hiddenSize * hiddenAmount + 2][i]
                        }
                    }

                    if (this.sigmoid(output[0][0]) > 0.55) this.jump()
                    else if (this.sigmoid(output[0][0]) < 0.45) this.crouch()
                    else this.isCrouching = false
                    // if (this.stepBack(output[0][0]) == 1) this.jump()
                    // if (this.stepBack(output[0][1] == 1)) this.crouch()
                }
                this.sigmoid = function(x) {
                    return 1 / (1 + Math.pow(Math.E, -x))
                }
                this.stepBack = function(x) {
                    if (x >= 1) return 1
                    return 0
                }
                this.height = this._height
                this.color = newColor()
                this.isOnTheAir = false
                this.velocity = 0
                this.isAlive = true
                this.x = 10
                this.y = canvas.height - this.height
                this.isCrouching = false

                this.fall = function() {
                    if (!this.isAlive) this.x--
                    
                    else if (this.y > canvas.height - this.height) {
                        this.isOnTheAir = false
                        this.y = canvas.height - this.height
                    } else if (this.isAlive && this.isOnTheAir) {
                        this.velocity += 1
                        this.y += this.velocity
                    }
                }
                this.jump = function() {
                    if (!this.isOnTheAir) {
                        this.velocity = -12.2
                        this.y += this.velocity
                        this.height = this._height
                        this.width = this._width
                        this.isOnTheAir = true
                        this.isCrouching = false
                    }
                }
                this.crouch = function() {
                    if (!this.isCrouching) {
                        this.height = this.height / 2
                        this.width += this.width / 2
                        this.y += this.height
                        this.velocity += 10
                        this.isCrouching = true
                    }
                }
            }

            function calcFitness(square, i) {
                if (isThereCollision(square, getTheClosestWall(square).wall, 'onlyX') && !square.hasJustScored && population[i].isAlive) {
                    square.fitness++
                    square.hasJustScored = true
                    setTimeout(() => {
                        square.hasJustScored = false
                    }, 150)
                }
            }

            function mutateBestDna(bestDna) {
                const arr = bestDna

                const randCol = Math.floor(Math.random() * arr.length)
                const randRow = Math.floor(Math.random() * arr[randCol].length)
                    
                bestDna = JSON.parse(JSON.stringify(bestDna))
                bestDna[randCol][randRow] = newWeight()

                return bestDna
            }

            function isThereCollision(a, b, option) {
                const disX = a.x - b.x
                const disY = a.y - b.y

                if (option == 'onlyX' && !(disY > -a.height && disY < b.height)) 
                    return disX > -a.width && disX < b.width

                if (disX > -a.width && disX < b.width &&
                    disY > -a.height && disY < b.height) return true
                return false
            }

            function draw(that) {
                ctx.fillStyle = that.color
                ctx.fillRect(that.x, that.y, that.width, that.height)
            }

            function calcWeightAmount(inpSize, hiddenSize, hiddenAmount, outpSize) {
                let weightAmount = inpSize * hiddenSize

                for (let c = 0; c < hiddenAmount; c++) {
                    if (c == hiddenAmount - 1) {
                        weightAmount += hiddenSize * outpSize
                    } else {
                        weightAmount += hiddenSize * hiddenSize
                    }
                }
                return {
                    inpSize: inpSize,
                    hiddenSize: hiddenSize,
                    hiddenAmount: hiddenAmount,
                    outpSize: outpSize,
                    weightAmount: weightAmount
                }
            }

            function getTheClosestWall(square) {
                let bestIndex = 0
                let bestX = Infinity

                for (let i = 0; i < walls.length; i++) {
                    if (walls[i].x > square.x && walls[i].x < bestX) {
                        bestIndex = i
                        bestX = walls[i].x
                    } 
                }
                return {
                    wallHeight: walls[bestIndex].height,
                    wallDistance: Math.abs(walls[bestIndex].x - square.x),
                    wallWidth: walls[bestIndex].width,
                    wall: walls[bestIndex]
                }
            }

            function createWalls(amount) {
                walls = []

                for (let i = 0; i < amount; i++) {
                    walls.push(new Wall())
                }
            }

            function newColor() {
                const hexadecimal = '0123456789ABCDEF'
                let color = '#'

                for (let i = 0; i < 6; i++) {
                    color += hexadecimal[Math.floor(Math.random() * 16)]
                }
                return color
            }

            function newWeight() {
                if (Math.random() > 0.5) 
                    return Math.random()
                return -Math.random()
            }
            
            createCanvas(300, 300)
            createPopulation(154)
            createWalls(5)

            run()
        </script>
    </body>
</html>